/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Khoj
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
function fileExtensionToMimeType(extension) {
  switch (extension) {
    case "pdf":
      return "application/pdf";
    case "png":
      return "image/png";
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "md":
    case "markdown":
      return "text/markdown";
    case "org":
      return "text/org";
    default:
      return "text/plain";
  }
}
function filenameToMimeType(filename) {
  switch (filename.extension) {
    case "pdf":
      return "application/pdf";
    case "png":
      return "image/png";
    case "jpg":
    case "jpeg":
      return "image/jpeg";
    case "md":
    case "markdown":
      return "text/markdown";
    case "org":
      return "text/org";
    default:
      console.warn(`Unknown file type: ${filename.extension}. Defaulting to text/plain.`);
      return "text/plain";
  }
}
async function updateContentIndex(vault, setting, lastSync, regenerate = false) {
  var _a;
  console.log(`Khoj: Updating Khoj content index...`);
  const files = vault.getFiles().filter((file) => file.extension === "md" || file.extension === "markdown" || file.extension === "pdf");
  const binaryFileTypes = ["pdf"];
  let countOfFilesToIndex = 0;
  let countOfFilesToDelete = 0;
  lastSync = lastSync.size > 0 ? lastSync : /* @__PURE__ */ new Map();
  const fileData = [];
  for (const file of files) {
    if (!regenerate && file.stat.mtime < ((_a = lastSync.get(file)) != null ? _a : 0)) {
      continue;
    }
    countOfFilesToIndex++;
    const encoding = binaryFileTypes.includes(file.extension) ? "binary" : "utf8";
    const mimeType = fileExtensionToMimeType(file.extension) + (encoding === "utf8" ? "; charset=UTF-8" : "");
    const fileContent = encoding == "binary" ? await vault.readBinary(file) : await vault.read(file);
    fileData.push({ blob: new Blob([fileContent], { type: mimeType }), path: file.path });
  }
  let filesToDelete = [];
  for (const lastSyncedFile of lastSync.keys()) {
    if (!files.includes(lastSyncedFile)) {
      countOfFilesToDelete++;
      let fileObj = new Blob([""], { type: filenameToMimeType(lastSyncedFile) });
      fileData.push({ blob: fileObj, path: lastSyncedFile.path });
      filesToDelete.push(lastSyncedFile);
    }
  }
  let responses = [];
  let error_message = null;
  for (let i = 0; i < fileData.length; i += 1e3) {
    const filesGroup = fileData.slice(i, i + 1e3);
    const formData = new FormData();
    filesGroup.forEach((fileItem) => {
      formData.append("files", fileItem.blob, fileItem.path);
    });
    const response = await fetch(`${setting.khojUrl}/api/v1/index/update?force=${regenerate}&client=obsidian`, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${setting.khojApiKey}`
      },
      body: formData
    });
    if (!response.ok) {
      if (response.status === 429) {
        error_message = `\u2757\uFE0FFailed to sync your content with Khoj server. Requests were throttled. Upgrade your subscription or try again later.`;
        break;
      } else if (response.status === 404) {
        error_message = `\u2757\uFE0FCould not connect to Khoj server. Ensure you can connect to it.`;
        break;
      } else {
        error_message = `\u2757\uFE0FFailed to sync your content with Khoj server. Raise issue on Khoj Discord or Github
Error: ${response.statusText}`;
      }
    } else {
      responses.push(await response.text());
    }
  }
  files.filter((file) => responses.find((response) => response.includes(file.path))).reduce((newSync, file) => {
    newSync.set(file, new Date().getTime());
    return newSync;
  }, lastSync);
  filesToDelete.filter((file) => responses.find((response) => response.includes(file.path))).forEach((file) => lastSync.delete(file));
  if (error_message) {
    new import_obsidian.Notice(error_message);
  } else {
    console.log(`\u2705 Refreshed Khoj content index. Updated: ${countOfFilesToIndex} files, Deleted: ${countOfFilesToDelete} files.`);
  }
  return lastSync;
}
async function createNote(name, newLeaf = false) {
  var _a, _b;
  try {
    let pathPrefix;
    switch (app.vault.getConfig("newFileLocation")) {
      case "current":
        pathPrefix = ((_b = (_a = app.workspace.getActiveFile()) == null ? void 0 : _a.parent.path) != null ? _b : "") + "/";
        break;
      case "folder":
        pathPrefix = this.app.vault.getConfig("newFileFolderPath") + "/";
        break;
      default:
        pathPrefix = "";
        break;
    }
    await app.workspace.openLinkText(`${pathPrefix}${name}.md`, "", newLeaf);
  } catch (e) {
    console.error("Khoj: Could not create note.\n" + e.message);
    throw e;
  }
}
async function createNoteAndCloseModal(query, modal, opt) {
  try {
    await createNote(query, opt == null ? void 0 : opt.newLeaf);
  } catch (e) {
    new import_obsidian.Notice(e.message);
    return;
  }
  modal.close();
}
async function canConnectToBackend(khojUrl, khojApiKey, showNotice = false) {
  let connectedToBackend = false;
  let userEmail = "";
  if (!!khojUrl) {
    let headers = !!khojApiKey ? { "Authorization": `Bearer ${khojApiKey}` } : void 0;
    await (0, import_obsidian.request)({ url: `${khojUrl}/api/health`, method: "GET", headers }).then((response) => {
      var _a;
      connectedToBackend = true;
      userEmail = (_a = JSON.parse(response)) == null ? void 0 : _a.email;
    }).catch((error) => {
      connectedToBackend = false;
      console.log(`Khoj connection error:

${error}`);
    });
  }
  let statusMessage = getBackendStatusMessage(connectedToBackend, userEmail, khojUrl, khojApiKey);
  if (showNotice)
    new import_obsidian.Notice(statusMessage);
  return { connectedToBackend, statusMessage, userEmail };
}
function getBackendStatusMessage(connectedToServer, userEmail, khojUrl, khojApiKey) {
  if (!khojApiKey && khojUrl === "https://app.khoj.dev")
    return `\u{1F308} Welcome to Khoj! Get your API key from ${khojUrl}/config#clients and set it in the Khoj plugin settings on Obsidian`;
  if (!connectedToServer)
    return `\u2757\uFE0FCould not connect to Khoj at ${khojUrl}. Ensure your can access it`;
  else if (!userEmail)
    return `\u2705 Connected to Khoj. \u2757\uFE0FGet a valid API key from ${khojUrl}/config#clients to log in`;
  else if (userEmail === "default@example.com")
    return `\u2705 Signed in to Khoj`;
  else
    return `\u2705 Signed in to Khoj as ${userEmail}`;
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  resultsCount: 6,
  khojUrl: "https://app.khoj.dev",
  khojApiKey: "",
  connectedToBackend: false,
  autoConfigure: true,
  lastSync: /* @__PURE__ */ new Map(),
  userEmail: ""
};
var KhojSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let backendStatusEl = containerEl.createEl("small", {
      text: getBackendStatusMessage(this.plugin.settings.connectedToBackend, this.plugin.settings.userEmail, this.plugin.settings.khojUrl, this.plugin.settings.khojApiKey)
    });
    let backendStatusMessage = "";
    new import_obsidian2.Setting(containerEl).setName("Khoj URL").setDesc("The URL of the Khoj backend.").addText((text) => text.setValue(`${this.plugin.settings.khojUrl}`).onChange(async (value) => {
      this.plugin.settings.khojUrl = value.trim().replace(/\/$/, "");
      ({
        connectedToBackend: this.plugin.settings.connectedToBackend,
        userEmail: this.plugin.settings.userEmail,
        statusMessage: backendStatusMessage
      } = await canConnectToBackend(this.plugin.settings.khojUrl, this.plugin.settings.khojApiKey));
      await this.plugin.saveSettings();
      backendStatusEl.setText(backendStatusMessage);
    }));
    new import_obsidian2.Setting(containerEl).setName("Khoj API Key").setDesc("Use Khoj Cloud with your Khoj API Key").addText((text) => text.setValue(`${this.plugin.settings.khojApiKey}`).onChange(async (value) => {
      this.plugin.settings.khojApiKey = value.trim();
      ({
        connectedToBackend: this.plugin.settings.connectedToBackend,
        userEmail: this.plugin.settings.userEmail,
        statusMessage: backendStatusMessage
      } = await canConnectToBackend(this.plugin.settings.khojUrl, this.plugin.settings.khojApiKey));
      await this.plugin.saveSettings();
      backendStatusEl.setText(backendStatusMessage);
    }));
    new import_obsidian2.Setting(containerEl).setName("Results Count").setDesc("The number of results to show in search and use for chat.").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.resultsCount).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.resultsCount = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto Sync").setDesc("Automatically index your vault with Khoj.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoConfigure).onChange(async (value) => {
      this.plugin.settings.autoConfigure = value;
      await this.plugin.saveSettings();
    }));
    let indexVaultSetting = new import_obsidian2.Setting(containerEl);
    indexVaultSetting.setName("Force Sync").setDesc("Manually force Khoj to re-index your Obsidian Vault.").addButton((button) => button.setButtonText("Update").setCta().onClick(async () => {
      button.setButtonText("Updating \u{1F311}");
      button.removeCta();
      indexVaultSetting = indexVaultSetting.setDisabled(true);
      const progress_indicator = window.setInterval(() => {
        if (button.buttonEl.innerText === "Updating \u{1F311}") {
          button.setButtonText("Updating \u{1F318}");
        } else if (button.buttonEl.innerText === "Updating \u{1F318}") {
          button.setButtonText("Updating \u{1F317}");
        } else if (button.buttonEl.innerText === "Updating \u{1F317}") {
          button.setButtonText("Updating \u{1F316}");
        } else if (button.buttonEl.innerText === "Updating \u{1F316}") {
          button.setButtonText("Updating \u{1F315}");
        } else if (button.buttonEl.innerText === "Updating \u{1F315}") {
          button.setButtonText("Updating \u{1F314}");
        } else if (button.buttonEl.innerText === "Updating \u{1F314}") {
          button.setButtonText("Updating \u{1F313}");
        } else if (button.buttonEl.innerText === "Updating \u{1F313}") {
          button.setButtonText("Updating \u{1F312}");
        } else if (button.buttonEl.innerText === "Updating \u{1F312}") {
          button.setButtonText("Updating \u{1F311}");
        }
      }, 300);
      this.plugin.registerInterval(progress_indicator);
      this.plugin.settings.lastSync = await updateContentIndex(this.app.vault, this.plugin.settings, this.plugin.settings.lastSync, true);
      new import_obsidian2.Notice("\u2705 Updated Khoj index.");
      window.clearInterval(progress_indicator);
      button.setButtonText("Update");
      button.setCta();
      indexVaultSetting = indexVaultSetting.setDisabled(false);
    }));
  }
};

// src/search_modal.ts
var import_obsidian3 = require("obsidian");
var KhojSearchModal = class extends import_obsidian3.SuggestModal {
  constructor(app2, setting, find_similar_notes = false) {
    super(app2);
    this.rerank = false;
    this.query = "";
    this.app = app2;
    this.setting = setting;
    this.find_similar_notes = find_similar_notes;
    this.inputEl.hidden = this.find_similar_notes;
    this.scope.register(["Mod"], "Enter", async () => {
      this.rerank = true;
      this.inputEl.dispatchEvent(new Event("input"));
      this.rerank = false;
    });
    this.scope.register(["Shift"], "Enter", async () => {
      if (this.query != "")
        createNoteAndCloseModal(this.query, this);
    });
    this.scope.register(["Ctrl", "Shift"], "Enter", async () => {
      if (this.query != "")
        createNoteAndCloseModal(this.query, this, { newLeaf: true });
    });
    const modalInstructions = [
      {
        command: "\u2191\u2193",
        purpose: "to navigate"
      },
      {
        command: "\u21B5",
        purpose: "to open"
      },
      {
        command: import_obsidian3.Platform.isMacOS ? "cmd \u21B5" : "ctrl \u21B5",
        purpose: "to rerank"
      },
      {
        command: "esc",
        purpose: "to dismiss"
      }
    ];
    this.setInstructions(modalInstructions);
    this.setPlaceholder("Search with Khoj...");
  }
  async onOpen() {
    if (this.find_similar_notes) {
      let file = this.app.workspace.getActiveFile();
      if (file && file.extension === "md") {
        this.rerank = true;
        this.inputEl.value = await this.app.vault.read(file).then((file_str) => file_str.slice(0, 42110));
        this.inputEl.dispatchEvent(new Event("input"));
        this.rerank = false;
      } else {
        this.resultContainerEl.setText("Cannot find similar notes for non-markdown files");
      }
    }
  }
  async getSuggestions(query) {
    let encodedQuery = encodeURIComponent(query);
    let searchUrl = `${this.setting.khojUrl}/api/search?q=${encodedQuery}&n=${this.setting.resultsCount}&r=${this.rerank}&client=obsidian`;
    let headers = { "Authorization": `Bearer ${this.setting.khojApiKey}` };
    let response = await (0, import_obsidian3.request)({ url: `${searchUrl}`, headers });
    let results = JSON.parse(response).filter((result) => {
      var _a;
      return !this.find_similar_notes || !result.additional.file.endsWith((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path);
    }).map((result) => {
      return { entry: result.entry, file: result.additional.file };
    });
    this.query = query;
    return results;
  }
  async renderSuggestion(result, el) {
    let lines_to_render = 8;
    let os_path_separator = result.file.includes("\\") ? "\\" : "/";
    let filename = result.file.split(os_path_separator).pop();
    result.entry = result.entry.replace(/---[\n\r][\s\S]*---[\n\r]/, "");
    let entry_snipped_indicator = result.entry.split("\n").length > lines_to_render ? " **...**" : "";
    let snipped_entry = result.entry.split("\n").slice(0, lines_to_render).join("\n");
    el.createEl("div", { cls: "khoj-result-file" }).setText(filename != null ? filename : "");
    let result_el = el.createEl("div", { cls: "khoj-result-entry" });
    import_obsidian3.MarkdownRenderer.renderMarkdown(snipped_entry + entry_snipped_indicator, result_el, result.file, null);
  }
  async onChooseSuggestion(result, _) {
    const mdFiles = this.app.vault.getMarkdownFiles();
    const pdfFiles = this.app.vault.getFiles().filter((file) => file.extension === "pdf");
    let file_match = mdFiles.concat(pdfFiles).sort((a, b) => b.path.length - a.path.length).find((file) => result.file.replace(/\\/g, "/").endsWith(file.path));
    if (file_match) {
      let resultHeading = file_match.extension !== "pdf" ? result.entry.split("\n", 1)[0] : "";
      let linkToEntry = resultHeading.startsWith("#") ? `${file_match.path}${resultHeading}` : file_match.path;
      this.app.workspace.openLinkText(linkToEntry, "");
      console.log(`Link: ${linkToEntry}, File: ${file_match.path}, Heading: ${resultHeading}`);
    }
  }
};

// src/chat_modal.ts
var import_obsidian4 = require("obsidian");
var KhojChatModal = class extends import_obsidian4.Modal {
  constructor(app2, setting) {
    super(app2);
    this.setting = setting;
    this.scope.register([], "Enter", async () => {
      await this.chat();
    });
    fetch("https://ipapi.co/json").then((response) => response.json()).then((data) => {
      this.region = data.region;
      this.city = data.city;
      this.countryName = data.country_name;
    }).catch((err) => {
      console.log(err);
      return;
    });
  }
  async chat() {
    let input_el = this.contentEl.getElementsByClassName("khoj-chat-input")[0];
    let user_message = input_el.value.trim();
    input_el.value = "";
    this.autoResize();
    await this.getChatResponse(user_message);
  }
  async onOpen() {
    let { contentEl } = this;
    contentEl.addClass("khoj-chat");
    contentEl.createEl("h1", { attr: { id: "khoj-chat-title" }, text: "Khoj Chat" });
    let chatBodyEl = contentEl.createDiv({ attr: { id: "khoj-chat-body", class: "khoj-chat-body" } });
    let inputRow = contentEl.createDiv("khoj-input-row");
    let clearChat = inputRow.createEl("button", {
      text: "Clear History",
      attr: {
        class: "khoj-input-row-button clickable-icon"
      }
    });
    clearChat.addEventListener("click", async (_) => {
      await this.clearConversationHistory();
    });
    (0, import_obsidian4.setIcon)(clearChat, "trash");
    let chatInput = inputRow.createEl("textarea", {
      attr: {
        id: "khoj-chat-input",
        autofocus: "autofocus",
        class: "khoj-chat-input option"
      }
    });
    chatInput.addEventListener("input", (_) => {
      this.onChatInput();
    });
    chatInput.addEventListener("keydown", (event) => {
      this.incrementalChat(event);
    });
    let transcribe = inputRow.createEl("button", {
      text: "Transcribe",
      attr: {
        id: "khoj-transcribe",
        class: "khoj-transcribe khoj-input-row-button clickable-icon "
      }
    });
    transcribe.addEventListener("mousedown", async (event) => {
      await this.speechToText(event);
    });
    transcribe.addEventListener("touchstart", async (event) => {
      await this.speechToText(event);
    });
    transcribe.addEventListener("touchend", async (event) => {
      await this.speechToText(event);
    });
    transcribe.addEventListener("touchcancel", async (event) => {
      await this.speechToText(event);
    });
    (0, import_obsidian4.setIcon)(transcribe, "mic");
    let send = inputRow.createEl("button", {
      text: "Send",
      attr: {
        id: "khoj-chat-send",
        class: "khoj-chat-send khoj-input-row-button clickable-icon"
      }
    });
    (0, import_obsidian4.setIcon)(send, "arrow-up-circle");
    let sendImg = send.getElementsByClassName("lucide-arrow-up-circle")[0];
    sendImg.addEventListener("click", async (_) => {
      await this.chat();
    });
    let getChatHistorySucessfully = await this.getChatHistory(chatBodyEl);
    let placeholderText = getChatHistorySucessfully ? "Message" : "Configure Khoj to enable chat";
    chatInput.placeholder = placeholderText;
    chatInput.disabled = !getChatHistorySucessfully;
    this.scrollChatToBottom();
    chatInput.focus();
  }
  generateReference(messageEl, reference, index) {
    let escaped_ref = reference.replace(/"/g, "&quot;");
    let short_ref = escaped_ref.slice(0, 100);
    short_ref = short_ref.length < escaped_ref.length ? short_ref + "..." : short_ref;
    let referenceButton = messageEl.createEl("button");
    referenceButton.textContent = short_ref;
    referenceButton.id = `ref-${index}`;
    referenceButton.classList.add("reference-button");
    referenceButton.classList.add("collapsed");
    referenceButton.tabIndex = 0;
    referenceButton.addEventListener("click", function() {
      console.log(`Toggling ref-${index}`);
      if (this.classList.contains("collapsed")) {
        this.classList.remove("collapsed");
        this.classList.add("expanded");
        this.textContent = escaped_ref;
      } else {
        this.classList.add("collapsed");
        this.classList.remove("expanded");
        this.textContent = short_ref;
      }
    });
    return referenceButton;
  }
  renderMessageWithReferences(chatEl, message, sender, context, dt, intentType, inferredQueries) {
    if (!message) {
      return;
    } else if (intentType == null ? void 0 : intentType.includes("text-to-image")) {
      let imageMarkdown = "";
      if (intentType === "text-to-image") {
        imageMarkdown = `![](data:image/png;base64,${message})`;
      } else if (intentType === "text-to-image2") {
        imageMarkdown = `![](${message})`;
      }
      if (inferredQueries) {
        imageMarkdown += "\n\n**Inferred Query**:";
        for (let inferredQuery of inferredQueries) {
          imageMarkdown += `

${inferredQuery}`;
        }
      }
      this.renderMessage(chatEl, imageMarkdown, sender, dt);
      return;
    } else if (!context) {
      this.renderMessage(chatEl, message, sender, dt);
      return;
    } else if (!!context && (context == null ? void 0 : context.length) === 0) {
      this.renderMessage(chatEl, message, sender, dt);
      return;
    }
    let chatMessageEl = this.renderMessage(chatEl, message, sender, dt);
    let chatMessageBodyEl = chatMessageEl.getElementsByClassName("khoj-chat-message-text")[0];
    let references = chatMessageBodyEl.createDiv();
    let referenceExpandButton = references.createEl("button");
    referenceExpandButton.classList.add("reference-expand-button");
    let numReferences = 0;
    if (context) {
      numReferences += context.length;
    }
    let referenceSection = references.createEl("div");
    referenceSection.classList.add("reference-section");
    referenceSection.classList.add("collapsed");
    referenceExpandButton.addEventListener("click", function() {
      if (referenceSection.classList.contains("collapsed")) {
        referenceSection.classList.remove("collapsed");
        referenceSection.classList.add("expanded");
      } else {
        referenceSection.classList.add("collapsed");
        referenceSection.classList.remove("expanded");
      }
    });
    references.classList.add("references");
    if (context) {
      context.map((reference, index) => {
        this.generateReference(referenceSection, reference, index + 1);
      });
    }
    let expandButtonText = numReferences == 1 ? "1 reference" : `${numReferences} references`;
    referenceExpandButton.innerHTML = expandButtonText;
  }
  renderMessage(chatEl, message, sender, dt, raw = false) {
    let message_time = this.formatDate(dt != null ? dt : new Date());
    let emojified_sender = sender == "khoj" ? "\u{1F3EE} Khoj" : "\u{1F914} You";
    let chatMessageEl = chatEl.createDiv({
      attr: {
        "data-meta": `${emojified_sender} at ${message_time}`,
        class: `khoj-chat-message ${sender}`
      }
    });
    let chat_message_body_el = chatMessageEl.createDiv();
    chat_message_body_el.addClasses(["khoj-chat-message-text", sender]);
    let chat_message_body_text_el = chat_message_body_el.createDiv();
    if (raw) {
      chat_message_body_text_el.innerHTML = message;
    } else {
      import_obsidian4.MarkdownRenderer.renderMarkdown(message, chat_message_body_text_el, "", null);
    }
    chatMessageEl.style.userSelect = "text";
    this.scrollChatToBottom();
    return chatMessageEl;
  }
  createKhojResponseDiv(dt) {
    let message_time = this.formatDate(dt != null ? dt : new Date());
    let chat_body_el = this.contentEl.getElementsByClassName("khoj-chat-body")[0];
    let chat_message_el = chat_body_el.createDiv({
      attr: {
        "data-meta": `\u{1F3EE} Khoj at ${message_time}`,
        class: `khoj-chat-message khoj`
      }
    }).createDiv({
      attr: {
        class: `khoj-chat-message-text khoj`
      }
    });
    this.scrollChatToBottom();
    return chat_message_el;
  }
  async renderIncrementalMessage(htmlElement, additionalMessage) {
    this.result += additionalMessage;
    htmlElement.innerHTML = "";
    await import_obsidian4.MarkdownRenderer.renderMarkdown(this.result, htmlElement, "", null);
    this.scrollChatToBottom();
  }
  formatDate(date) {
    let time_string = date.toLocaleTimeString("en-IN", { hour: "2-digit", minute: "2-digit", hour12: false });
    let date_string = date.toLocaleString("en-IN", { year: "numeric", month: "short", day: "2-digit" }).replace(/-/g, " ");
    return `${time_string}, ${date_string}`;
  }
  async getChatHistory(chatBodyEl) {
    var _a, _b;
    let chatUrl = `${this.setting.khojUrl}/api/chat/history?client=obsidian`;
    try {
      let response = await fetch(chatUrl, {
        method: "GET",
        headers: { "Authorization": `Bearer ${this.setting.khojApiKey}` }
      });
      let responseJson = await response.json();
      if (responseJson.detail) {
        let setupMsg = "Hi \u{1F44B}\u{1F3FE}, to start chatting add available chat models options via [the Django Admin panel](/server/admin) on the Server";
        this.renderMessage(chatBodyEl, setupMsg, "khoj", void 0);
        return false;
      } else if (responseJson.response) {
        let chatLogs = ((_a = responseJson.response) == null ? void 0 : _a.conversation_id) ? (_b = responseJson.response.chat) != null ? _b : [] : responseJson.response;
        chatLogs.forEach((chatLog) => {
          var _a2, _b2;
          this.renderMessageWithReferences(chatBodyEl, chatLog.message, chatLog.by, chatLog.context, new Date(chatLog.created), (_a2 = chatLog.intent) == null ? void 0 : _a2.type, (_b2 = chatLog.intent) == null ? void 0 : _b2["inferred-queries"]);
        });
      }
    } catch (err) {
      let errorMsg = "Unable to get response from Khoj server \u2764\uFE0F\u200D\u{1FA79}. Ensure server is running or contact developers for help at [team@khoj.dev](mailto:team@khoj.dev) or in [Discord](https://discord.gg/BDgyabRM6e)";
      this.renderMessage(chatBodyEl, errorMsg, "khoj", void 0);
      return false;
    }
    return true;
  }
  async readChatStream(response, responseElement) {
    if (response.body == null)
      return;
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    while (true) {
      const { value, done } = await reader.read();
      if (done)
        break;
      let responseText = decoder.decode(value);
      if (responseText.includes("### compiled references:")) {
        const [additionalResponse, rawReference] = responseText.split("### compiled references:", 2);
        await this.renderIncrementalMessage(responseElement, additionalResponse);
        const rawReferenceAsJson = JSON.parse(rawReference);
        let references = responseElement.createDiv();
        references.classList.add("references");
        let referenceExpandButton = references.createEl("button");
        referenceExpandButton.classList.add("reference-expand-button");
        let referenceSection = references.createDiv();
        referenceSection.classList.add("reference-section");
        referenceSection.classList.add("collapsed");
        let numReferences = 0;
        if (Array.isArray(rawReferenceAsJson)) {
          numReferences = rawReferenceAsJson.length;
          rawReferenceAsJson.forEach((reference, index) => {
            this.generateReference(referenceSection, reference, index);
          });
        }
        references.appendChild(referenceExpandButton);
        referenceExpandButton.addEventListener("click", function() {
          if (referenceSection.classList.contains("collapsed")) {
            referenceSection.classList.remove("collapsed");
            referenceSection.classList.add("expanded");
          } else {
            referenceSection.classList.add("collapsed");
            referenceSection.classList.remove("expanded");
          }
        });
        let expandButtonText = numReferences == 1 ? "1 reference" : `${numReferences} references`;
        referenceExpandButton.innerHTML = expandButtonText;
        references.appendChild(referenceSection);
      } else {
        await this.renderIncrementalMessage(responseElement, responseText);
      }
    }
  }
  async getChatResponse(query) {
    var _a;
    if (!query || query === "")
      return;
    let chatBodyEl = this.contentEl.getElementsByClassName("khoj-chat-body")[0];
    this.renderMessage(chatBodyEl, query, "you");
    let encodedQuery = encodeURIComponent(query);
    let chatUrl = `${this.setting.khojUrl}/api/chat?q=${encodedQuery}&n=${this.setting.resultsCount}&client=obsidian&stream=true&region=${this.region}&city=${this.city}&country=${this.countryName}`;
    let responseElement = this.createKhojResponseDiv();
    this.result = "";
    await this.renderIncrementalMessage(responseElement, "\u{1F914}");
    let response = await fetch(chatUrl, {
      method: "GET",
      headers: {
        "Content-Type": "text/event-stream",
        "Authorization": `Bearer ${this.setting.khojApiKey}`
      }
    });
    try {
      if (response.body === null) {
        throw new Error("Response body is null");
      }
      if (responseElement.innerHTML === "\u{1F914}") {
        responseElement.innerHTML = "";
      }
      this.result = "";
      responseElement.innerHTML = "";
      if (response.headers.get("content-type") === "application/json") {
        let responseText = "";
        try {
          const responseAsJson = await response.json();
          if (responseAsJson.image) {
            if (responseAsJson.intentType === "text-to-image") {
              responseText += `![${query}](data:image/png;base64,${responseAsJson.image})`;
            } else if (responseAsJson.intentType === "text-to-image2") {
              responseText += `![${query}](${responseAsJson.image})`;
            }
            const inferredQuery = (_a = responseAsJson.inferredQueries) == null ? void 0 : _a[0];
            if (inferredQuery) {
              responseText += `

**Inferred Query**:

${inferredQuery}`;
            }
          } else if (responseAsJson.detail) {
            responseText = responseAsJson.detail;
          }
        } catch (error) {
          responseText = await response.text();
        } finally {
          await this.renderIncrementalMessage(responseElement, responseText);
        }
      } else {
        await this.readChatStream(response, responseElement);
      }
    } catch (err) {
      console.log(`Khoj chat response failed with
${err}`);
      let errorMsg = "Sorry, unable to get response from Khoj backend \u2764\uFE0F\u200D\u{1FA79}. Retry or contact developers for help at <a href=mailto:'team@khoj.dev'>team@khoj.dev</a> or <a href='https://discord.gg/BDgyabRM6e'>on Discord</a>";
      responseElement.innerHTML = errorMsg;
    }
  }
  flashStatusInChatInput(message) {
    let chatInput = this.contentEl.getElementsByClassName("khoj-chat-input")[0];
    let originalPlaceholder = chatInput.placeholder;
    chatInput.placeholder = message;
    setTimeout(() => {
      chatInput.placeholder = originalPlaceholder;
    }, 2e3);
  }
  async clearConversationHistory() {
    let chatBody = this.contentEl.getElementsByClassName("khoj-chat-body")[0];
    let response = await (0, import_obsidian4.request)({
      url: `${this.setting.khojUrl}/api/chat/history?client=obsidian`,
      method: "DELETE",
      headers: { "Authorization": `Bearer ${this.setting.khojApiKey}` }
    });
    try {
      let result = JSON.parse(response);
      if (result.status !== "ok") {
        throw new Error("Failed to clear conversation history");
      } else {
        let getChatHistoryStatus = await this.getChatHistory(chatBody);
        if (getChatHistoryStatus)
          chatBody.innerHTML = "";
        let statusMsg = getChatHistoryStatus ? result.message : "Failed to clear conversation history";
        this.flashStatusInChatInput(statusMsg);
      }
    } catch (err) {
      this.flashStatusInChatInput("Failed to clear conversation history");
    }
  }
  async speechToText(event) {
    var _a;
    event.preventDefault();
    const transcribeButton = this.contentEl.getElementsByClassName("khoj-transcribe")[0];
    const chatInput = this.contentEl.getElementsByClassName("khoj-chat-input")[0];
    const sendButton = this.modalEl.getElementsByClassName("khoj-chat-send")[0];
    const generateRequestBody = async (audioBlob, boundary_string) => {
      const boundary = `------${boundary_string}`;
      const chunks = [];
      chunks.push(new TextEncoder().encode(`${boundary}\r
`));
      chunks.push(new TextEncoder().encode(`Content-Disposition: form-data; name="file"; filename="blob"\r
Content-Type: "application/octet-stream"\r
\r
`));
      chunks.push(await audioBlob.arrayBuffer());
      chunks.push(new TextEncoder().encode("\r\n"));
      await Promise.all(chunks);
      chunks.push(new TextEncoder().encode(`${boundary}--\r
`));
      return await new Blob(chunks).arrayBuffer();
    };
    const sendToServer = async (audioBlob) => {
      const boundary_string = `Boundary${Math.random().toString(36).slice(2)}`;
      const requestBody = await generateRequestBody(audioBlob, boundary_string);
      const response = await (0, import_obsidian4.requestUrl)({
        url: `${this.setting.khojUrl}/api/transcribe?client=obsidian`,
        method: "POST",
        headers: { "Authorization": `Bearer ${this.setting.khojApiKey}` },
        contentType: `multipart/form-data; boundary=----${boundary_string}`,
        body: requestBody
      });
      if (response.status === 200) {
        console.log(response);
        chatInput.value += response.json.text.trimStart();
        this.autoResize();
      } else if (response.status === 501) {
        throw new Error("\u26D4\uFE0F Configure speech-to-text model on server.");
      } else if (response.status === 422) {
        throw new Error("\u26D4\uFE0F Audio file to large to process.");
      } else {
        throw new Error("\u26D4\uFE0F Failed to transcribe audio.");
      }
      if (chatInput.value.length === 0)
        return;
      (0, import_obsidian4.setIcon)(sendButton, "stop-circle");
      let stopSendButtonImg = sendButton.getElementsByClassName("lucide-stop-circle")[0];
      stopSendButtonImg.addEventListener("click", (_) => {
        this.cancelSendMessage();
      });
      stopSendButtonImg.getElementsByTagName("circle")[0].style.animation = "countdown 3s linear 1 forwards";
      this.sendMessageTimeout = setTimeout(() => {
        (0, import_obsidian4.setIcon)(sendButton, "arrow-up-circle");
        let sendImg = sendButton.getElementsByClassName("lucide-arrow-up-circle")[0];
        sendImg.addEventListener("click", async (_) => {
          await this.chat();
        });
        this.chat();
      }, 3e3);
    };
    const handleRecording = (stream) => {
      const audioChunks = [];
      const recordingConfig = { mimeType: "audio/webm" };
      this.mediaRecorder = new MediaRecorder(stream, recordingConfig);
      this.mediaRecorder.addEventListener("dataavailable", function(event2) {
        if (event2.data.size > 0)
          audioChunks.push(event2.data);
      });
      this.mediaRecorder.addEventListener("stop", async function() {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        await sendToServer(audioBlob);
      });
      this.mediaRecorder.start();
      (0, import_obsidian4.setIcon)(transcribeButton, "mic-off");
    };
    if (!this.mediaRecorder || this.mediaRecorder.state === "inactive" || event.type === "touchstart") {
      (_a = navigator.mediaDevices.getUserMedia({ audio: true })) == null ? void 0 : _a.then(handleRecording).catch((e) => {
        this.flashStatusInChatInput("\u26D4\uFE0F Failed to access microphone");
      });
    } else if (this.mediaRecorder.state === "recording" || event.type === "touchend" || event.type === "touchcancel") {
      this.mediaRecorder.stop();
      this.mediaRecorder.stream.getTracks().forEach((track) => track.stop());
      this.mediaRecorder = void 0;
      (0, import_obsidian4.setIcon)(transcribeButton, "mic");
    }
  }
  cancelSendMessage() {
    clearTimeout(this.sendMessageTimeout);
    let sendButton = this.modalEl.getElementsByClassName("khoj-chat-send")[0];
    (0, import_obsidian4.setIcon)(sendButton, "arrow-up-circle");
    let sendImg = sendButton.getElementsByClassName("lucide-arrow-up-circle")[0];
    sendImg.addEventListener("click", async (_) => {
      await this.chat();
    });
  }
  incrementalChat(event) {
    if (!event.shiftKey && event.key === "Enter") {
      event.preventDefault();
      this.chat();
    }
  }
  onChatInput() {
    const chatInput = this.contentEl.getElementsByClassName("khoj-chat-input")[0];
    chatInput.value = chatInput.value.trimStart();
    this.autoResize();
  }
  autoResize() {
    const chatInput = this.contentEl.getElementsByClassName("khoj-chat-input")[0];
    const scrollTop = chatInput.scrollTop;
    chatInput.style.height = "0";
    const scrollHeight = chatInput.scrollHeight + 8;
    chatInput.style.height = Math.min(scrollHeight, 200) + "px";
    chatInput.scrollTop = scrollTop;
    this.scrollChatToBottom();
  }
  scrollChatToBottom() {
    let sendButton = this.modalEl.getElementsByClassName("khoj-chat-send")[0];
    sendButton.scrollIntoView({ behavior: "auto", block: "center" });
  }
};

// src/main.ts
var Khoj = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "search",
      name: "Search",
      callback: () => {
        new KhojSearchModal(this.app, this.settings).open();
      }
    });
    this.addCommand({
      id: "similar",
      name: "Find similar notes",
      editorCallback: () => {
        new KhojSearchModal(this.app, this.settings, true).open();
      }
    });
    this.addCommand({
      id: "chat",
      name: "Chat",
      callback: () => {
        new KhojChatModal(this.app, this.settings).open();
      }
    });
    this.addRibbonIcon("message-circle", "Khoj", (_) => {
      new KhojChatModal(this.app, this.settings).open();
    });
    this.addSettingTab(new KhojSettingTab(this.app, this));
    this.indexingTimer = setInterval(async () => {
      if (this.settings.autoConfigure) {
        this.settings.lastSync = await updateContentIndex(this.app.vault, this.settings, this.settings.lastSync);
      }
    }, 60 * 60 * 1e3);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    ({ connectedToBackend: this.settings.connectedToBackend } = await canConnectToBackend(this.settings.khojUrl, this.settings.khojApiKey, true));
  }
  async saveSettings() {
    this.saveData(this.settings);
  }
  async onunload() {
    if (this.indexingTimer)
      clearInterval(this.indexingTimer);
    this.unload();
  }
};
